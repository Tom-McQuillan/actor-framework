name: "Manual Test Workflow"

on:
  issues:
    types: [opened, edited, labeled]

concurrency:
  group: manual-test-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  process-manual-test:
    runs-on: ubuntu-latest

    steps:
      # 1) Save the entire event payload in base64 form to avoid shell-parse errors.
      - name: Prepare event JSON
        run: |
          echo "GITHUB_EVENT_PAYLOAD=$(echo '${{ toJson(github.event) }}' | base64 -w0)" >> $GITHUB_ENV

      # 2) Check label 'manual-test' & title prefix '[Manual Test]'
      - name: Check if 'manual-test' label exists & title starts with '[Manual Test]'
        id: label_and_title_check
        run: |
          # Decode the event JSON from base64
          EVENT_JSON="$(echo "$GITHUB_EVENT_PAYLOAD" | base64 -d)"

          # Extract labels and title from the decoded JSON
          LABELS="$(echo "$EVENT_JSON" | jq -r '.issue.labels[].name')"
          ISSUE_TITLE="$(echo "$EVENT_JSON" | jq -r '.issue.title')"

          echo "Labels found: $LABELS"
          echo "Issue title: $ISSUE_TITLE"

          # Check for exact 'manual-test' label
          echo "$LABELS" | grep -xq 'manual-test' || {
            echo "Label 'manual-test' not present. Skipping."
            echo "::set-output name=skip::true"
            exit 0
          }

          # Check if issue title starts with '[Manual Test]'
          if [[ "$ISSUE_TITLE" != "[Manual Test]"* ]]; then
            echo "Issue title does not start with '[Manual Test]'. Skipping."
            echo "::set-output name=skip::true"
            exit 0
          fi

          echo "::set-output name=skip::false"

      - name: Stop if skip was requested
        if: steps.label_and_title_check.outputs.skip == 'true'
        run: |
          echo "Skipping workflow."
          exit 0

      - name: Parse issue body
        id: parse_body
        uses: actions/github-script@v6
        with:
          script: |
            const issueBody = `\${
              process.env.ISSUE_BODY || ''
            }`.trim() || `\${
              github.event.issue.body || ''
            }`.trim();

            // Utility function to get the line after a heading, if present
            function getField(fieldLabel) {
              // We search line by line for an exact match or a line that starts with the label
              const lines = issueBody.split('\n');
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.includes(fieldLabel)) {
                  // If value is on the same line after ':', or we take next line
                  // For simplicity, just check next line in this example:
                  if (lines[i+1]) {
                    return lines[i+1].trim();
                  }
                }
              }
              return null; // Not found
            }

            const requiredFields = {
              test_id: '🧪 Select a Test',
              test_result: '✅ Test Result',
              os_used: '🖥️ Operating System',
              labview_version: '🧰 LabVIEW Version Used',
              labview_bitness: '💻 LabVIEW Bitness'
            };

            // Parse required fields
            let parsed = {};
            for (const [key, label] of Object.entries(requiredFields)) {
              const val = getField(label);
              if (!val) {
                core.setFailed(`Missing or invalid field: '${key}' (label: '${label}')`);
                return;
              }
              parsed[key] = val;
            }

            // Validate test_result
            const validResults = ['Passed', 'Failed', 'Needs Review'];
            if (!validResults.includes(parsed.test_result)) {
              core.setFailed(`Invalid test_result: '${parsed.test_result}'. Must be 'Passed', 'Failed', or 'Needs Review'.`);
              return;
            }

            // Parse optional notes
            const notesLabel = '📝 Notes or Screenshots (optional)';
            const optionalNotes = getField(notesLabel) || '';
            parsed.notes = optionalNotes;

            core.setOutput('test_id', parsed.test_id);
            core.setOutput('test_result', parsed.test_result);
            core.setOutput('os_used', parsed.os_used);
            core.setOutput('labview_version', parsed.labview_version);
            core.setOutput('labview_bitness', parsed.labview_bitness);
            core.setOutput('notes', parsed.notes);

      - name: Find matching table row and parse numeric TestID + Estimate
        id: parse_table
        uses: actions/github-script@v6
        with:
          script: |
            const issueBody = `\${
              github.event.issue.body || ''
            }`;

            const testAlias = core.getInput('test_id', { stepId: 'parse_body' });
            // Convert underscores to spaces, for table matching
            const testTitle = testAlias.replace(/_/g, ' ');

            // Simple table parsing approach: you might have a markdown table like:
            // | Title           | Est. Time | Link                    |
            // | --------------- | --------- | ----------------------- |
            // | Actor Creation  | *20 Min*  | [Doc](.../1713129.md)   |
            //
            // We'll do a naive search for a row containing "Actor Creation" ignoring case
            // Then parse out the .md from that row if possible.

            // 1) Attempt to split the body by lines
            const lines = issueBody.split('\n');

            let matchedRow = null;
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              // Check if this line might be a row that has '|' as table columns
              if (line.startsWith('|') && line.endsWith('|')) {
                // Does it contain testTitle ignoring case?
                const lowerLine = line.toLowerCase();
                if (lowerLine.includes(testTitle.toLowerCase())) {
                  matchedRow = line;
                  break;
                }
              }
            }

            if (!matchedRow) {
              core.setFailed(`No table row found for title '${testTitle}' in the issue body.`);
              return;
            }

            // Expected columns: Title | Est. Time | Link
            // We'll split on '|', ignoring first/last since they might be empty.
            const columns = matchedRow.split('|').map(c => c.trim()).filter(Boolean);
            // e.g. columns[0] => Title, columns[1] => Est. Time, columns[2] => Link
            if (columns.length < 3) {
              core.setFailed(`Matched row does not have at least 3 columns: '${matchedRow}'`);
              return;
            }

            const rowTitle = columns[0];
            const rowEstTime = columns[1];
            const rowLink = columns[2];

            // 2) Extract the numeric .md from rowLink
            // We'll look for a pattern like `.../1234567.md`
            const mdRegex = /\/(\d{7})\.md/;
            const match = rowLink.match(mdRegex);
            if (!match) {
              core.setFailed(`No 7-digit .md file found in link column: '${rowLink}'`);
              return;
            }

            const numericTestID = match[1]; // e.g. "1713129"

            // 3) Clean up the Est. Time string (remove surrounding asterisks)
            const cleanedEstTime = rowEstTime.replace(/\*/g, '').trim();
            if (!cleanedEstTime) {
              core.setFailed(`Est. Time is missing or empty for row: '${matchedRow}'`);
              return;
            }

            core.setOutput('numeric_test_id', numericTestID);
            core.setOutput('estimate', cleanedEstTime)

      - name: Retrieve or create Project Item & set End date (if not set)
        id: project_item
        uses: actions/github-script@v6
        with:
          script: |
            const issueNodeId = github.event.issue.node_id;
            const createdAt = github.event.issue.created_at; // e.g., "2025-04-19T12:34:56Z"

            // The node ID of the project (Beta) you're updating:
            // e.g. "PVT_kwHOA-abcdefg" (You must replace this with your actual project node ID)
            const projectNodeId = process.env.PROJECT_NODE_ID || 'YOUR_PROJECT_NODE_ID';

            // Field IDs (replace with your actual IDs from the project)
            const fieldId_endDate        = process.env.FIELD_ID_ENDDATE        || 'ENDDATE_FIELD_ID';
            const fieldId_startDate      = process.env.FIELD_ID_STARTDATE      || 'STARTDATE_FIELD_ID';
            // We'll store them in step outputs for future usage
            core.setOutput('FIELD_ID_ENDDATE', fieldId_endDate);
            core.setOutput('FIELD_ID_STARTDATE', fieldId_startDate);

            // 1) Find or create the project item for this issue
            // Query for an existing item in the project with this issue node_id
            const existingItemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100, filterBy: {contentId: $contentId}) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                          }
                        }
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldDateValue {
                              field {
                                id
                              }
                              date
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            let existingItemResp = await github.graphql(existingItemQuery, {
              projectId: projectNodeId,
              contentId: issueNodeId
            }).catch((err) => {
              core.setFailed(`Failed to query project item: ${err.message}`);
              return;
            });

            if (!existingItemResp) {
              return; // already failed
            }

            let projectItemId = null;
            let endDateAlreadySet = null;

            const items = existingItemResp.node.items.nodes;
            if (items.length > 0) {
              // There's an existing item
              projectItemId = items[0].id;
              // Check if there's an End date set
              const fieldValues = items[0].fieldValues.nodes;
              const endDateField = fieldValues.find(f => f.field.id === fieldId_endDate);
              if (endDateField && endDateField.date) {
                endDateAlreadySet = endDateField.date; 
              }
            } else {
              // No item found, create one
              const createItemMutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                    item {
                      id
                    }
                  }
                }
              `;
              let createResp = await github.graphql(createItemMutation, {
                projectId: projectNodeId,
                contentId: issueNodeId
              }).catch((err) => {
                core.setFailed(`Failed to create project item: ${err.message}`);
                return;
              });
              if (!createResp) {
                return; // already failed
              }
              projectItemId = createResp.addProjectV2ItemById.item.id;
            }

            if (!projectItemId) {
              core.setFailed('Could not find or create the project item.');
              return;
            }

            // 2) If End date is not set, set it now:
            if (!endDateAlreadySet) {
              const updateEndDateMutation = `
                mutation($itemId: ID!, $fieldId: ID!, $value: String) {
                  updateProjectV2ItemFieldValue(
                    input: { projectId: "${projectNodeId}", itemId: $itemId, fieldId: $fieldId, value: { date: $value } }
                  ) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              let updateResp = await github.graphql(updateEndDateMutation, {
                itemId: projectItemId,
                fieldId: fieldId_endDate,
                value: createdAt
              }).catch((err) => {
                core.setFailed(`Failed to set End date: ${err.message}`);
                return;
              });
              if (!updateResp) {
                return; // already failed
              }
            }

            // Output the item ID so we can update other fields in subsequent steps
            core.setOutput('project_item_id', projectItemId);

      - name: Find the previous [Manual Test] issue's End date (if any)
        id: get_previous_end_date
        uses: actions/github-script@v6
        with:
          script: |
            // We'll do a quick search for issues created by the same author that have
            // label=manual-test and title starts with [Manual Test], sorted by creation date descending.
            // Then pick the first that isn't our current issue.
            //
            // This uses the GitHub REST "search issues" endpoint or the GraphQL. We'll do a simplified approach using REST here:
            // The maximum search limit is 1000 results, but presumably this is enough for manual testing backlog.
            // We will parse out the item in the project and read its End date field.

            const currentAuthor = github.event.issue.user.login;
            const currentIssueNumber = github.event.issue.number;

            // Simple approach: "repo:<owner>/<repo> is:issue label:manual-test in:title '[Manual Test]' author:@theUser sort:created-desc"
            // Then filter out the current issue. The first result that is not the current issue is the "previous" one.
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // The search query must be URL-encoded
            // For example: q=repo:owner/repo+is:issue+label:manual-test+in:title+"[Manual Test]"+author:theUser+sort:created-desc
            const q = `repo:${owner}/${repo} is:issue label:manual-test author:${currentAuthor} in:title "[Manual Test]" sort:created-desc`;

            let searchResp = await github.rest.search.issuesAndPullRequests({
              q,
              per_page: 5 // limit to 5 for performance
            }).catch(err => {
              core.setFailed(`Search for previous issues failed: ${err.message}`);
            });
            if (!searchResp) return; // already failed

            const items = searchResp.data.items;
            if (!items || items.length === 0) {
              // No previous issues at all
              core.setOutput('previous_end_date', '');
              return;
            }

            // Filter out the current issue
            const filtered = items.filter(i => i.number !== currentIssueNumber);
            if (filtered.length === 0) {
              // No previous
              core.setOutput('previous_end_date', '');
              return;
            }

            // The first in filtered is the most recently created before the current one
            const previousIssue = filtered[0];
            // Now we must read that issue's Project item to get the End date

            const projectNodeId = process.env.PROJECT_NODE_ID || 'YOUR_PROJECT_NODE_ID';
            const fieldId_endDate = core.getInput('FIELD_ID_ENDDATE', { stepId: 'project_item' });

            // We'll need to do a GraphQL query to find that item and read the End date
            const prevItemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100, filterBy: {contentId: $contentId}) {
                      nodes {
                        id
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldDateValue {
                              field {
                                id
                              }
                              date
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const prevIssueNodeId = previousIssue.node_id;
            let prevQueryResp = await github.graphql(prevItemQuery, {
              projectId: projectNodeId,
              contentId: prevIssueNodeId
            }).catch((err) => {
              core.setFailed(`Failed to query previous issue item: ${err.message}`);
              return;
            });
            if (!prevQueryResp) return; // failed already

            const prevItems = prevQueryResp.node.items.nodes;
            if (prevItems.length === 0) {
              // The previous issue might not be in the project
              core.setOutput('previous_end_date', '');
              return;
            }

            const prevFieldValues = prevItems[0].fieldValues.nodes;
            const endDateFieldVal = prevFieldValues.find(f => f.field.id === fieldId_endDate);
            if (!endDateFieldVal || !endDateFieldVal.date) {
              // No end date
              core.setOutput('previous_end_date', '');
              return;
            }

            core.setOutput('previous_end_date', endDateFieldVal.date);

      - name: Update fields (Start date, TestID, Estimate, etc.)
        uses: actions/github-script@v6
        with:
          script: |
            const projectItemId = core.getInput('project_item_id', { stepId: 'project_item' });
            if (!projectItemId) {
              core.setFailed('No project item ID available.');
              return;
            }

            const projectNodeId = process.env.PROJECT_NODE_ID || 'YOUR_PROJECT_NODE_ID';

            // Field IDs from environment or from earlier steps
            const fieldId_endDate       = core.getInput('FIELD_ID_ENDDATE',       { stepId: 'project_item' });
            const fieldId_startDate     = core.getInput('FIELD_ID_STARTDATE',     { stepId: 'project_item' });
            const fieldId_testID        = process.env.FIELD_ID_TESTID        || 'TESTID_FIELD_ID';
            const fieldId_estimate      = process.env.FIELD_ID_ESTIMATE      || 'ESTIMATE_FIELD_ID';
            const fieldId_testResult    = process.env.FIELD_ID_TESTRESULT    || 'TESTRESULT_FIELD_ID';
            const fieldId_osUsed        = process.env.FIELD_ID_OSUSED        || 'OSUSED_FIELD_ID';
            const fieldId_lvVersion     = process.env.FIELD_ID_LVVERSION     || 'LVVERSION_FIELD_ID';
            const fieldId_lvBitness     = process.env.FIELD_ID_LVBITNESS     || 'LVBITNESS_FIELD_ID';
            const fieldId_notes         = process.env.FIELD_ID_NOTES         || 'NOTES_FIELD_ID';

            // Inputs from previous steps
            const numericTestId = core.getInput('numeric_test_id', { stepId: 'parse_table' });
            const estimateValue = core.getInput('estimate', { stepId: 'parse_table' });
            const testResult    = core.getInput('test_result', { stepId: 'parse_body' });
            const osUsed        = core.getInput('os_used', { stepId: 'parse_body' });
            const lvVersion     = core.getInput('labview_version', { stepId: 'parse_body' });
            const lvBitness     = core.getInput('labview_bitness', { stepId: 'parse_body' });
            const notes         = core.getInput('notes', { stepId: 'parse_body' });
            const previousEndDate = core.getInput('previous_end_date', { stepId: 'get_previous_end_date' });

            // Build list of fields to update
            const fieldsToUpdate = [];

            // 1) Start date = previous issue’s End date (if any, and if not empty)
            if (previousEndDate) {
              fieldsToUpdate.push({
                fieldId: fieldId_startDate,
                value: { date: previousEndDate }
              });
            }

            // 2) TestID (text)
            fieldsToUpdate.push({
              fieldId: fieldId_testID,
              value: { text: numericTestId }
            });

            // 3) Estimate (text)
            fieldsToUpdate.push({
              fieldId: fieldId_estimate,
              value: { text: estimateValue }
            });

            // 4) Test Result (single-select)
            fieldsToUpdate.push({
              fieldId: fieldId_testResult,
              value: { singleSelectOptionId: null, name: testResult }
              // If you have actual single-select options in your project, you need the exact option ID. 
              // Many times you can update by name in Beta, but it depends on your project configuration.
            });

            // 5) Operating System (text)
            fieldsToUpdate.push({
              fieldId: fieldId_osUsed,
              value: { text: osUsed }
            });

            // 6) LabVIEW Version (text)
            fieldsToUpdate.push({
              fieldId: fieldId_lvVersion,
              value: { text: lvVersion }
            });

            // 7) LabVIEW Bitness (text)
            fieldsToUpdate.push({
              fieldId: fieldId_lvBitness,
              value: { text: lvBitness }
            });

            // 8) Notes (text)
            fieldsToUpdate.push({
              fieldId: fieldId_notes,
              value: { text: notes }
            });

            // We'll run a single GraphQL mutation for each field or do them in bulk.
            // Example: multiple calls in a loop:
            for (const field of fieldsToUpdate) {
              const { fieldId, value } = field;
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: $value
                    }
                  ) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              try {
                let resp = await github.graphql(mutation, {
                  projectId: projectNodeId,
                  itemId: projectItemId,
                  fieldId: fieldId,
                  value: value
                });
              } catch (err) {
                core.setFailed(`Failed to update field '${fieldId}': ${err.message}`);
                return;
              }
            }

            core.notice('Successfully updated project fields!');
