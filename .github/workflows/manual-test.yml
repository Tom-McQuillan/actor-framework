name: Manual Test Report

on:
  issues:
    types: [opened, edited]   # run on new issues and any later edits

permissions:                  # minimum permissions the job needs
  contents: read
  issues: write               # we’ll update the issue title/labels if we want
  pull-requests: write

jobs:
  process-manual-test:
    if: contains(github.event.issue.title, '[Manual Test]')   # ignore unrelated issues
    runs-on: ubuntu-latest

    steps:
    #--------------------------------------------------------------------
    # 1) Check out the repository so we can read the issue‑form template
    #--------------------------------------------------------------------
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 1

    #--------------------------------------------------------------------
    # 2) Parse the issue‑form the tester just submitted
    #--------------------------------------------------------------------
    - name: Parse issue form
      id: parse
      uses: issue-ops/parser@v1.0.0
      with:
        body: ${{ github.event.issue.body }}
        issue-form-template: manual-test-report.yml   # <- path inside .github/ISSUE_TEMPLATE/
        workspace: ${{ github.workspace }}

    #--------------------------------------------------------------------
    # 3) Collect all values we’ll push to the project
    #--------------------------------------------------------------------
    - name: Build field set
      id: build
      run: |
        {
          echo "test_id=${{ steps.parse.outputs.numeric_test_id }}"
          echo "estimate=${{ steps.parse.outputs.estimate_text }}"
          echo "lv_version=${{ steps.parse.outputs.labview_version }}"
          echo "bitness=${{ steps.parse.outputs.labview_bitness }}"
          echo "os_used=${{ steps.parse.outputs.os_used }}"
          echo "test_result=${{ steps.parse.outputs.test_result }}"
          echo "notes=${{ steps.parse.outputs.notes }}"
        } >> "$GITHUB_OUTPUT"

    #--------------------------------------------------------------------
    # 4) Push everything to the NI Actor Framework **organisation project**
    #    – creates missing fields / options automatically and logs every step
    #--------------------------------------------------------------------
    - name: Update project fields
      uses: actions/github-script@v6
      env:
        PROJECT_ID: PVT_kwDOCgMyo84AFVsT          # ← node‑ID for https://github.com/orgs/ni/projects/29
        TEST_ID:      ${{ steps.build.outputs.test_id }}
        ESTIMATE:     ${{ steps.build.outputs.estimate }}
        LV_VERSION:   ${{ steps.build.outputs.lv_version }}
        BITNESS:      ${{ steps.build.outputs.bitness }}
        OS_USED:      ${{ steps.build.outputs.os_used }}
        TEST_RESULT:  ${{ steps.build.outputs.test_result }}
        NOTES:        ${{ steps.build.outputs.notes }}
      with:
        github-token: ${{ secrets.PROJECTS_PAT }} # PAT needs “Projects (Read & Write)” + “Issues (Read)” scopes
        script: |
          const projectId   = process.env.PROJECT_ID;
          const contentId   = context.payload.issue.node_id;   // the issue itself
          const log         = (msg) => core.info(`  ${msg}`);

          // ------------------------------------------------------------
          // Helper 1: find or create a project item for the current issue
          // ------------------------------------------------------------
          async function ensureProjectItem() {
            const q = await github.graphql(`
              query ($projectId:ID!, $contentId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    title
                    items(first:100, query:$contentId) {
                      nodes { id content { ... on Issue { id } } }
                    }
                  }
                }
              }`, {projectId, contentId});

            const projectTitle = q.node.title;
            let item = q.node.items.nodes.find(n => n.content && n.content.id === contentId);

            if (item) {
              log(`Found existing project item ${item.id} in “${projectTitle}”.`);
              return item.id;
            }

            log(`No item yet – adding current issue to project “${projectTitle}”…`);
            const add = await github.graphql(`
              mutation ($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`, {projectId, contentId});
            return add.addProjectV2ItemById.item.id;
          }

          // ------------------------------------------------------------
          // Helper 2: list all existing project‑level custom fields
          // ------------------------------------------------------------
          async function getAllFields() {
            const res = await github.graphql(`
              query ($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    fields(first:100) {
                      nodes {
                        id name dataType
                        ... on ProjectV2SingleSelectField { options { id name } }
                      }
                    }
                  }
                }
              }`, {projectId});
            return res.node.fields.nodes;
          }

          // ------------------------------------------------------------
          // Helper 3: create a new field (text or single‑select)
          // ------------------------------------------------------------
          async function createField(name, type) {
            log(`Creating missing field “${name}”…`);
            const mutation = type === 'TEXT'
              ? `mutation ($projectId:ID!, $name:String!) {
                   createProjectV2Field(input:{
                     projectId:$projectId, name:$name, dataType:TEXT
                   }) { field { id name dataType } }
                 }`
              : `mutation ($projectId:ID!, $name:String!) {
                   createProjectV2Field(input:{
                     projectId:$projectId, name:$name, dataType:SINGLE_SELECT,
                     singleSelectOptions:[{name:"Passed"},{name:"Failed"},{name:"Needs Review"}]
                   }) {
                     field { id name dataType ... on ProjectV2SingleSelectField { options { id name } } }
                   }
                 }`;
            const res = await github.graphql(mutation, {projectId, name});
            return res.createProjectV2Field.field;
          }

          // ------------------------------------------------------------
          // Helper 4: update (or set) a field value on the item
          // ------------------------------------------------------------
          async function setField(itemId, field, rawValue) {
            let valuePayload;

            if (field.dataType === 'SINGLE_SELECT') {
              let opt = field.options.find(o => o.name === rawValue);
              if (!opt) {
                log(`Adding option “${rawValue}” to field “${field.name}”…`);
                const addOpt = await github.graphql(`
                  mutation ($projectId:ID!, $fieldId:ID!, $name:String!) {
                    createProjectV2SingleSelectFieldOption(input:{
                      projectId:$projectId, fieldId:$fieldId, name:$name
                    }) { option { id name } }
                  }`, {projectId, fieldId: field.id, name: rawValue});
                opt = addOpt.createProjectV2SingleSelectFieldOption.option;
                field.options.push(opt);
              }
              valuePayload = { singleSelectOptionId: opt.id };
            } else {
              valuePayload = { text: rawValue };
            }

            await github.graphql(`
              mutation ($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                }) { projectV2Item { id } }
              }`, {projectId, itemId, fieldId: field.id, value: valuePayload});

            log(`✅ Set “${field.name}” → “${rawValue}”`);
          }

          // =========== MAIN ===========================================
          log('🔍 Locating / creating project item');
          const itemId   = await ensureProjectItem();
          log('🗂  Gathering project fields');
          const fields   = await getAllFields();

          const wanted = [
            { name: 'TestID',           value: process.env.TEST_ID,     type: 'TEXT' },
            { name: 'Estimate',         value: process.env.ESTIMATE,    type: 'TEXT' },
            { name: 'Operating System', value: process.env.OS_USED,     type: 'TEXT' },
            { name: 'LabVIEW Version',  value: process.env.LV_VERSION,  type: 'TEXT' },
            { name: 'LabVIEW Bitness',  value: process.env.BITNESS,     type: 'TEXT' },
            { name: 'Notes',            value: process.env.NOTES,       type: 'TEXT' },
            { name: 'Test Result',      value: process.env.TEST_RESULT, type: 'SINGLE_SELECT' }
          ];

          log('✏️ Updating fields');
          for (const w of wanted) {
            if (!w.value) { log(`⚠️  Skipping “${w.name}” – no value provided`); continue; }

            let field = fields.find(f => f.name === w.name);
            if (!field) {
              field = await createField(w.name, w.type);
              fields.push(field);   // keep cache up to date
            }
            await setField(itemId, field, w.value);
          }

          log('🎉 All fields up to date!');
