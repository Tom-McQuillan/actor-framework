name: "Process Manual Test Issues"

on:
  issues:
    # We only trigger on these events. We do NOT include 'unlabeled'
    types: [opened, edited, labeled]

concurrency:
  group: manual-test-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  process-manual-test:
    runs-on: ubuntu-latest

    steps:
      ################################################################
      # STEP 1: Encode event JSON to avoid shell parsing complexity
      ################################################################
      - name: Capture event payload
        run: |
          echo "GITHUB_EVENT_PAYLOAD=$(echo '${{ toJson(github.event) }}' | base64 -w0)" >> $GITHUB_ENV

      ################################################################
      # STEP 2: Check for 'manual-test' label and `[Manual Test]` prefix
      #         If missing, skip. We do NOT run on 'unlabeled', so no error.
      ################################################################
      - name: Preliminary label/title check
        id: label_and_title
        run: |
          # Decode from base64
          EVENT_JSON="$(echo "$GITHUB_EVENT_PAYLOAD" | base64 -d)"

          # Extract labels, title from the JSON
          LABELS="$(echo "$EVENT_JSON" | jq -r '.issue.labels[].name')"
          ISSUE_TITLE="$(echo "$EVENT_JSON" | jq -r '.issue.title')"

          echo "Labels found:"
          echo "$LABELS"
          echo "Issue title: $ISSUE_TITLE"

          # Check exact label 'manual-test'
          echo "$LABELS" | grep -xq 'manual-test' || {
            echo "Label 'manual-test' not present. Skipping."
            echo "::set-output name=skip::true"
            exit 0
          }

          # Check title prefix
          if [[ "$ISSUE_TITLE" != "[Manual Test]"* ]]; then
            echo "Issue title does not start with '[Manual Test]'. Skipping."
            echo "::set-output name=skip::true"
            exit 0
          fi

          echo "::set-output name=skip::false"

      - name: Stop if skip
        if: steps.label_and_title.outputs.skip == 'true'
        run: |
          echo "Skipping workflow due to missing label or incorrect title prefix."
          exit 0

      ################################################################
      # STEP 3: Parse required form fields from the issue body
      #         (test_id, test_result, os_used, labview_version,
      #          labview_bitness) plus optional notes
      #         - Also skip blank lines to handle spacing
      ################################################################
      - name: Parse issue body
        id: parse_body
        uses: actions/github-script@v6
        with:
          script: |
            const issueBody = `${process.env.ISSUE_BODY || ''}`.trim()
              || `${github.event.issue.body || ''}`.trim();

            // Simple function to find label, then read the next non-blank line
            function getField(fieldLabel) {
              const lines = issueBody.split('\n');
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.includes(fieldLabel)) {
                  let j = i + 1;
                  while (j < lines.length) {
                    const nextLine = lines[j].trim();
                    if (nextLine !== '') {
                      return nextLine;
                    }
                    j++;
                  }
                  return null; // Only blank lines followed
                }
              }
              return null; // Not found
            }

            // Required fields
            const requiredFields = {
              test_id: '🧪 Select a Test',
              test_result: '✅ Test Result',
              os_used: '🖥️ Operating System',
              labview_version: '🧰 LabVIEW Version Used',
              labview_bitness: '💻 LabVIEW Bitness'
            };

            // Parse each required field
            let parsed = {};
            for (const [key, label] of Object.entries(requiredFields)) {
              const val = getField(label);
              if (!val) {
                core.setFailed(`Missing or invalid field: '${key}' (label: '${label}')`);
                return;
              }
              parsed[key] = val;
            }

            // Validate test_result
            const validResults = ['Passed', 'Failed', 'Needs Review'];
            if (!validResults.includes(parsed.test_result)) {
              core.setFailed(`Invalid test_result: '${parsed.test_result}'. Must be 'Passed', 'Failed', or 'Needs Review'.`);
              return;
            }

            // Optional notes
            const notesLabel = '📝 Notes or Screenshots (optional)';
            const optionalNotes = getField(notesLabel) || '';
            parsed.notes = optionalNotes;

            // Pass results to subsequent steps
            core.setOutput('test_id', parsed.test_id);
            core.setOutput('test_result', parsed.test_result);
            core.setOutput('os_used', parsed.os_used);
            core.setOutput('labview_version', parsed.labview_version);
            core.setOutput('labview_bitness', parsed.labview_bitness);
            core.setOutput('notes', parsed.notes);

      ################################################################
      # STEP 4: Extract numeric test ID from table + estimate time
      #         Example logic for scanning a markdown table
      ################################################################
      - name: Extract numeric testID and estimate from table
        id: parse_table
        uses: actions/github-script@v6
        with:
          script: |
            // We read the user-friendly test alias from the previous step
            const testAlias = core.getInput('test_id', { required: true });

            // We'll do a simplified example that scans the issue body for a table row
            // that has a Title matching the user-friendly alias (case-insensitive).
            // Then parse the numeric 7-digit link from the .md, plus the estimate.
            const body = github.event.issue.body || '';
            const lines = body.split('\n');

            let numericID = null;
            let estimateStr = null;

            // We'll do a naive parse for a row that looks like:
            // "| Title | *20 Min* | [Link](.../1234567.md) |"
            // We do a case-insensitive comparison for testAlias -> Title
            // Also transform underscores -> spaces in testAlias before matching
            const aliasForCompare = testAlias.replaceAll('_', ' ').toLowerCase();

            for (const line of lines) {
              const row = line.trim();
              if (!row.startsWith('|')) continue; // skip non-table lines

              // split by '|'
              const cells = row.split('|').map(c => c.trim());
              // for a row, cells might be: ['', 'Actor Creation', '*20 Min*', '[Link](...)', '']
              // we want Title in cells[1], estimate in cells[2], link in cells[3]
              if (cells.length < 4) continue;
              const rowTitle = cells[1] ? cells[1].toLowerCase() : '';
              const rowEstimate = cells[2] || '';
              const rowLink = cells[3] || '';

              if (rowTitle === aliasForCompare) {
                // parse link
                const mdLinkRegex = /\((.*?)\)/; // parentheses
                const match = rowLink.match(mdLinkRegex);
                if (!match) {
                  core.setFailed(`No link found in table row for alias: '${testAlias}'`);
                  return;
                }
                const linkURL = match[1]; // e.g. ".../1234567.md"

                // parse out the numeric portion from link
                const linkParts = linkURL.split('/');
                const lastSegment = linkParts[linkParts.length - 1];
                if (!lastSegment.endsWith('.md')) {
                  core.setFailed(`Link does not end with .md in table row for '${testAlias}': ${linkURL}`);
                  return;
                }
                const baseName = lastSegment.replace('.md',''); // "1234567"
                if (!/^\d{7}$/.test(baseName)) {
                  core.setFailed(`Table link is not a 7-digit ID: '${baseName}'`);
                  return;
                }
                numericID = baseName;

                // parse estimate (e.g. "*20 Min*" or "20 Min")
                const estimateClean = rowEstimate.replace(/\*/g, '').trim(); 
                if (!estimateClean) {
                  core.setFailed(`No Est. Time found in the table row for '${testAlias}'`);
                  return;
                }
                estimateStr = estimateClean;

                break;
              }
            }

            if (!numericID) {
              core.setFailed(`No matching row found in table for alias: '${testAlias}'`);
              return;
            }

            core.setOutput('numeric_id', numericID);
            core.setOutput('estimate', estimateStr);

      ################################################################
      # STEP 5: Determine Start date from the previous `[Manual Test]` issue
      #         and End date from the current issue creation if not set
      #         (We never overwrite End date if it already exists)
      ################################################################
      - name: Compute Start/End dates using GraphQL
        id: date_logic
        uses: actions/github-script@v6
        with:
          script: |
            /**
             * Pseudocode:
             * 1) GraphQL to find if this issue is already in the project (retrieve item).
             * 2) If item not found -> create it.
             * 3) If `End date` field not set, set it to the issue's created_at (first creation only).
             * 4) Find previous `[Manual Test]` issue from the same author, get its `End date`,
             *    and set that as this issue's `Start date` (unless we already have one).
             */

            const issueNumber = github.event.issue.number;
            const repoId = github.repository; // e.g. "org_name/repo_name"
            const createdAt = github.event.issue.created_at; // e.g. "2025-04-19T13:47:45Z"
            const authorLogin = github.event.issue.user.login;

            // Inputs from previous steps
            const numericID = core.getInput('numeric_id', { required: true });
            const estimateStr = core.getInput('estimate', { required: true });

            // Project + field placeholders. Replace with real IDs
            const PROJECT_ID = 'P2_ABCDEF'; // example
            const FIELD_ID__TEST_ID       = 'field_testid_123';
            const FIELD_ID__TEST_RESULT   = 'field_testresult_456';
            const FIELD_ID__OS            = 'field_os_789';
            const FIELD_ID__LV_VERSION    = 'field_lvvers_101112';
            const FIELD_ID__LV_BITNESS    = 'field_lvbitness_131415';
            const FIELD_ID__NOTES         = 'field_notes_161718';
            const FIELD_ID__ESTIMATE      = 'field_estimate_192021';
            const FIELD_ID__START_DATE    = 'field_start_222324';
            const FIELD_ID__END_DATE      = 'field_end_252627';

            const testResult = core.getInput('test_result');
            const osUsed = core.getInput('os_used');
            const lvVers = core.getInput('labview_version');
            const lvBit = core.getInput('labview_bitness');
            const notes = core.getInput('notes');
            const testID = numericID; // override user alias with numeric

            // 1) Query to see if there's an existing project item for this issue
            const findItemQuery = `
            query($projectId: ID!, $issueId: ID!) {
              resource(nodeId: $issueId) {
                ... on Issue {
                  projectItems(first: 30) {
                    nodes {
                      id
                      project {
                        id
                      }
                    }
                  }
                }
              }
            }`;

            // convert the issue to a nodeId with "Issue" prefix or we can parse from event. 
            // Typically 'github.event.issue.node_id' is available.
            const issueNodeId = github.event.issue.node_id; 

            const findItemResp = await github.graphql(findItemQuery, {
              projectId: PROJECT_ID,
              issueId: issueNodeId
            });

            let existingItemId = null;
            if (findItemResp.resource?.projectItems?.nodes?.length) {
              // find a node that matches the project
              for (const n of findItemResp.resource.projectItems.nodes) {
                if (n.project?.id === PROJECT_ID) {
                  existingItemId = n.id;
                  break;
                }
              }
            }

            // 2) If no item found, create one
            if (!existingItemId) {
              const addItemMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                  item {
                    id
                  }
                }
              }`;

              const addResp = await github.graphql(addItemMutation, {
                projectId: PROJECT_ID,
                contentId: issueNodeId
              });
              existingItemId = addResp.addProjectV2ItemById.item.id;
              core.info(`Created new project item: ${existingItemId}`);
            } else {
              core.info(`Project item already exists: ${existingItemId}`);
            }

            // 3) Attempt to read the existing 'End date' to see if it's set
            const readFieldQuery = `
            query($itemId: ID!, $endFieldId: ID!) {
              node(id: $itemId) {
                ... on ProjectV2Item {
                  fieldValues(first: 20) {
                    nodes {
                      ... on ProjectV2ItemFieldDateValue {
                        fieldId
                        date
                      }
                    }
                  }
                }
              }
            }`;
            const readFieldResp = await github.graphql(readFieldQuery, {
              itemId: existingItemId,
              endFieldId: FIELD_ID__END_DATE
            });

            let existingEndDate = null;
            if (readFieldResp.node?.fieldValues?.nodes) {
              for (const f of readFieldResp.node.fieldValues.nodes) {
                // We look for the 'date' from the field that matches 'FIELD_ID__END_DATE'
                if (f.fieldId === FIELD_ID__END_DATE && f.date) {
                  existingEndDate = f.date;
                  break;
                }
              }
            }

            let endDateToSet = existingEndDate;
            if (!endDateToSet) {
              // This is the "first creation" scenario
              endDateToSet = createdAt; // e.g. "2025-04-19T13:47:45Z"
            }

            // 4) Find previous [Manual Test] issue for the same author
            //    We'll do a naive approach using the GitHub search API or GraphQL
            //    e.g. search issues with author: same user, title starts with [Manual Test].
            //    Then sort by created date descending, exclude current issue
            const queryPrevious = await github.rest.search.issuesAndPullRequests({
              q: `repo:${repoId} is:issue author:${authorLogin} in:title "[Manual Test]" -${issueNumber} label:manual-test`,
              sort: 'created',
              order: 'desc',
              per_page: 1
            });

            let startDateToSet = null;
            if (queryPrevious.data.total_count > 0) {
              const prevIssue = queryPrevious.data.items[0];
              // We must fetch that issue's End date from the project
              const prevNodeId = prevIssue.node_id;

              // GraphQL read that same end date field
              // This is repeated logic or we can generalize a function, but for brevity we inline
              const prevFindItem = await github.graphql(findItemQuery, {
                projectId: PROJECT_ID,
                issueId: prevNodeId
              });

              let prevItemId = null;
              if (prevFindItem.resource?.projectItems?.nodes?.length) {
                for (const n of prevFindItem.resource.projectItems.nodes) {
                  if (n.project?.id === PROJECT_ID) {
                    prevItemId = n.id;
                    break;
                  }
                }
              }
              if (prevItemId) {
                // read end date from previous item
                const prevReadResp = await github.graphql(readFieldQuery, {
                  itemId: prevItemId,
                  endFieldId: FIELD_ID__END_DATE
                });
                if (prevReadResp.node?.fieldValues?.nodes) {
                  for (const f of prevReadResp.node.fieldValues.nodes) {
                    if (f.fieldId === FIELD_ID__END_DATE && f.date) {
                      startDateToSet = f.date;
                      break;
                    }
                  }
                }
              }
            }

            // Next: build a list of updates to apply
            // We never overwrite the End date if already set, but we set it if it was missing.
            // We always update other fields with new data.
            const updates = [
              {
                fieldId: FIELD_ID__TEST_ID,
                value: { text: testID }
              },
              {
                fieldId: FIELD_ID__TEST_RESULT,
                value: { singleSelectOptionId: null, singleSelectValue: testResult }
                // or if you store test_result as single-select by ID, you'd map the string to an option ID
              },
              {
                fieldId: FIELD_ID__OS,
                value: { text: osUsed }
              },
              {
                fieldId: FIELD_ID__LV_VERSION,
                value: { text: lvVers }
              },
              {
                fieldId: FIELD_ID__LV_BITNESS,
                value: { text: lvBit }
              },
              {
                fieldId: FIELD_ID__NOTES,
                value: { text: notes }
              },
              {
                fieldId: FIELD_ID__ESTIMATE,
                value: { text: estimateStr }
              }
            ];

            if (startDateToSet) {
              updates.push({
                fieldId: FIELD_ID__START_DATE,
                value: { date: startDateToSet }
              });
            }

            updates.push({
              fieldId: FIELD_ID__END_DATE,
              value: { date: endDateToSet }
            });

            // 5) Perform each field update with a GraphQL mutation
            const updateMutation = `
            mutation UpdateFields($itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
              updateProjectV2ItemFieldValue(
                input: { 
                  projectId: "${PROJECT_ID}",
                  itemId: $itemId,
                  fieldId: $fieldId,
                  value: $value
                }
              ) {
                projectV2Item {
                  id
                }
              }
            }
            `;

            for (const u of updates) {
              // skip setting End date if it was already set & not changed
              if (u.fieldId === FIELD_ID__END_DATE && existingEndDate) {
                // We only set endDate if it was missing
                continue;
              }

              core.info(`Updating field ${u.fieldId} with ${JSON.stringify(u.value)}`);
              try {
                await github.graphql(updateMutation, {
                  itemId: existingItemId,
                  fieldId: u.fieldId,
                  value: u.value
                });
              } catch (err) {
                core.setFailed(`Project update failed for fieldId ${u.fieldId} => ${err.message}`);
                return;
              }
            }

            core.notice(`Project fields updated successfully for itemId: ${existingItemId}`);

      ################################################################
      # STEP 6: Success
      ################################################################
      - name: Done
        run: echo "Workflow completed successfully."
