name: Manual Test ‚Üí Project Sync

on:
  issues:
    types: [opened, edited]          # run both on create AND when the issue is modified

permissions:                        # least‚Äëprivilege for the built‚Äëin token
  contents: read
  issues: write
  pull-requests: write

env:                                # constants for your organisation project
  ORG_NAME: ni
  PROJECT_NUMBER: 29                # << your org‚Äëlevel Project number

jobs:
  sync-with-project:
    runs-on: ubuntu-latest

    steps:
    # --------------------------------------------------------------
    # 0) Parse the issue‚Äëform that reporters submit
    # --------------------------------------------------------------
    - name: Parse Issue‚Äëform
      id: parse
      uses: issue-ops/parser@v1.0.0
      with:
        issue-form-template: manual-test-report.yml
        body: ${{ github.event.issue.body }}

    # --------------------------------------------------------------
    # 1) Resolve the *node¬†ID* of org‚Äëproject¬†#29
    #    (needs the PAT because it‚Äôs an organisation resource)
    # --------------------------------------------------------------
    - name: Get Project node¬†ID
      id: project
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.PROJECTS_PAT }}
        result-encoding: string
        script: |
          const {ORG_NAME, PROJECT_NUMBER} = process.env;
          const data = await github.graphql(`
            query ($org: String!, $num: Int!) {
              organization(login: $org) {
                projectV2(number: $num) { id title }
              }
            }`,
            { org: ORG_NAME, num: parseInt(PROJECT_NUMBER,10) }
          );

          const proj = data.organization?.projectV2;
          if (!proj?.id) core.setFailed(`Project #${PROJECT_NUMBER} not found in org ${ORG_NAME}`);

          core.info(`üóÇ  Project "${proj.title}" ‚Üí ${proj.id}`);
          core.setOutput('id', proj.id);

    # --------------------------------------------------------------
    # 2) Add / update the issue in the project and fill in fields
    # --------------------------------------------------------------
    - name: Update Project fields
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.PROJECTS_PAT }}
        script: |
          // ---------- helpers ----------
          const projId    = '${{ steps.project.outputs.id }}';
          const contentId = context.payload.issue.node_id;

          const wanted = {                    // values coming from the parsed form
            "TestID":            '${{ steps.parse.outputs.numeric_test_id }}',
            "Estimate":          '${{ steps.parse.outputs.estimate_text }}',
            "Operating System":  '${{ steps.parse.outputs.operating_system }}',
            "LabVIEW Version":   '${{ steps.parse.outputs.labview_version_used }}',
            "LabVIEW Bitness":   '${{ steps.parse.outputs.labview_bitness }}',
            "Notes":             '${{ steps.parse.outputs.notes_or_screenshots_optional }}',
            "Test Result":       '${{ steps.parse.outputs.test_result }}'   // single‚Äëselect
          };

          // ---------- locate (or create) the project item ----------
          core.startGroup('üîç Locating project item(s)');
          const found = await github.graphql(`
            query($p:ID!,$c:ID!){
              node(id:$p){
                ... on ProjectV2{
                  items(first:20){
                    nodes{ id content{ ... on Issue{ id } } }
                  }
                }
              }
            }`, {p: projId, c: contentId});

          let itemId = found.node.items.nodes.find(n => n.content?.id === contentId)?.id;
          core.info(`Found ${itemId ? 'existing' : 'no'} item for this issue`);
          core.endGroup();

          if (!itemId) {
            const add = await github.graphql(`
              mutation($p:ID!,$c:ID!){
                addProjectV2ItemById(input:{projectId:$p,contentId:$c}){item{id}}
              }`, {p: projId, c: contentId});
            itemId = add.addProjectV2ItemById.item.id;
            core.notice(`‚ûï Created project item ${itemId}`);
          }

          // ---------- load fields on the project ----------
          core.startGroup('üóÉÔ∏è Loading project fields');
          const meta = await github.graphql(`
            query($p:ID!){
              node(id:$p){
                ... on ProjectV2{
                  fields(first:100){
                    nodes{
                      id name dataType
                      ... on ProjectV2SingleSelectField{ options{ id name } }
                    }
                  }
                }
              }
            }`, {p: projId});

          const fieldMap = Object.fromEntries(
            meta.node.fields.nodes.map(f => [f.name, f])
          );
          core.info(`Fields present: ${Object.keys(fieldMap).join(', ')}`);
          core.endGroup();

          // ---------- ensure all desired fields exist ----------
          for (const [name] of Object.entries(wanted)) {
            if (fieldMap[name]) continue;       // already present

            const dataType = name === 'Test Result' ? 'SINGLE_SELECT' : 'TEXT';
            const res = await github.graphql(`
              mutation($p:ID!,$n:String!,$t:ProjectV2CustomFieldType!){
                createProjectV2Field(input:{projectId:$p,name:$n,dataType:$t}){field{id name dataType}}
              }`, {p: projId, n: name, t: dataType});
            fieldMap[name] = res.createProjectV2Field.field;
            core.notice(`üõ†Ô∏è  Created field "${name}" (${fieldMap[name].id})`);
          }

          // ---------- make sure the single‚Äëselect option exists ----------
          if (fieldMap['Test Result']?.dataType === 'SINGLE_SELECT') {
            const sel = fieldMap['Test Result'];
            const val = wanted['Test Result'];

            let optId = sel.options?.find(o => o.name === val)?.id;
            if (!optId) {
              const crt = await github.graphql(`
                mutation ($fid:ID!, $n:String!){
                  createProjectV2SingleSelectFieldOption(input:{fieldId:$fid,name:$n}){
                    singleSelectFieldOption{id name}
                  }
                }`, {fid: sel.id, n: val});
              optId = crt.createProjectV2SingleSelectFieldOption.singleSelectFieldOption.id;
              core.notice(`‚öôÔ∏è  Added single‚Äëselect option "${val}"`);
            }
            sel.optionId = optId;
          }

          // ---------- push values into the item ----------
          core.startGroup('‚úèÔ∏è Updating fields');
          for (const [name,value] of Object.entries(wanted)) {
            if (!value) continue;               // nothing to write
            const f = fieldMap[name];
            if (!f) { core.warning(`Field ‚Äú${name}‚Äù missing ‚Äì skipped`); continue; }

            if (f.dataType === 'SINGLE_SELECT') {
              await github.graphql(`
                mutation($p:ID!,$i:ID!,$f:ID!,$o:ID!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$p,itemId:$i,fieldId:$f,
                    value:{singleSelectOptionId:$o}
                  }){projectV2Item{id}}
                }`, {p: projId, i: itemId, f: f.id, o: f.optionId});
              core.info(`‚úì ${name} ‚Üí ${value}`);
            } else {
              await github.graphql(`
                mutation($p:ID!,$i:ID!,$f:ID!,$txt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$p,itemId:$i,fieldId:$f,
                    value:{text:$txt}
                  }){projectV2Item{id}}
                }`, {p: projId, i: itemId, f: f.id, txt: value});
              core.info(`‚úì ${name} ‚Üí ${value}`);
            }
          }
          core.endGroup();
