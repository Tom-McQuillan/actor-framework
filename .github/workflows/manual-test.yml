name: "Process Manual Test Issues"

on:
  issues:
    types:
      - opened
      - edited
      - labeled    # NOTE: we do NOT trigger on 'unlabeled'

concurrency:
  group: manual-test-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  process-manual-test:
    runs-on: ubuntu-latest
    steps:

      #────────────────────────────────────────────────────────────────────────────
      # STEP 1: Capture the full event payload so we never rely on `github.event.issue`
      #────────────────────────────────────────────────────────────────────────────
      - name: Capture GitHub event payload
        run: |
          echo "GITHUB_EVENT_PAYLOAD=$(echo '${{ toJson(github.event) }}' \
            | base64 -w0)" >> $GITHUB_ENV

      #────────────────────────────────────────────────────────────────────────────
      # STEP 2: Quick skip if no manual-test label or title prefix
      #────────────────────────────────────────────────────────────────────────────
      - name: Preliminary label/title check
        id: label_and_title
        run: |
          EVENT_JSON=$(echo "$GITHUB_EVENT_PAYLOAD" | base64 -d)
          LABELS=$(echo "$EVENT_JSON" | jq -r '.issue.labels[].name')
          TITLE=$(echo "$EVENT_JSON" | jq -r '.issue.title')

          if ! echo "$LABELS" | grep -xq 'manual-test'; then
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [[ "$TITLE" != "[Manual Test]"* ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Abort if skipping
        if: steps.label_and_title.outputs.skip == 'true'
        run: |
          echo "⏭️  Skipping manual‑test workflow."
          exit 0

      #────────────────────────────────────────────────────────────────────────────
      # STEP 3: Parse every field from the issue body (handles blank lines)
      #────────────────────────────────────────────────────────────────────────────
      - name: Parse form fields
        id: parse_body
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const payload = JSON.parse(
              Buffer.from(process.env.GITHUB_EVENT_PAYLOAD, 'base64').toString()
            );
            const body = (payload.issue.body || '').trim();

            function getField(label) {
              const lines = body.split('\n');
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes(label)) {
                  let j = i + 1;
                  while (j < lines.length) {
                    const txt = lines[j].trim();
                    if (txt) return txt;
                    j++;
                  }
                  return null;
                }
              }
              return null;
            }

            // Map every custom field label to a key
            const mapping = {
              test_id:      '🧪 Select a Test',
              labview_version: '🧰 LabVIEW Version Used',
              labview_bitness: '💻 LabVIEW Bitness',
              os_used:      '🖥️ Operating System',
              test_result:  '✅ Test Result',
              notes:        '📝 Notes or Screenshots (optional)',
              estimate:     'Estimate',
              start_date:   'Start Date',
              end_date:     'End Date'
            };

            const parsed = {};
            for (const [key, label] of Object.entries(mapping)) {
              const v = getField(label);
              if (!v && key !== 'notes') {
                core.setFailed(`Missing or invalid field '${key}' (label: '${label}')`);
                return;
              }
              parsed[key] = v || '';
            }

            // Validate Test Result
            if (!['Passed','Failed','Needs Review'].includes(parsed.test_result)) {
              core.setFailed(
                `Invalid Test Result '${parsed.test_result}'. Must be Passed, Failed, or Needs Review.`
              );
              return;
            }

            // Validate Estimate is numeric
            if (!/^\d+(\.\d+)?$/.test(parsed.estimate)) {
              core.setFailed(`Estimate must be a number. Got: '${parsed.estimate}'`);
              return;
            }

            // (You can add date‐format validation for start_date/end_date here if you like)

            // Emit everything as outputs
            for (const [k, v] of Object.entries(parsed)) {
              core.setOutput(k, v);
            }

      #────────────────────────────────────────────────────────────────────────────
      # STEP 4: Extract numeric TestID & Estimate for downstream steps
      #────────────────────────────────────────────────────────────────────────────
      - name: Extract numeric TestID & Estimate
        id: extract_numeric
        run: |
          raw_test_id="${{ steps.parse_body.outputs.test_id }}"
          raw_estimate="${{ steps.parse_body.outputs.estimate }}"

          numeric_test_id=$(echo "$raw_test_id" | grep -oE '[0-9]+' || true)
          numeric_estimate=$(echo "$raw_estimate" | grep -oE '[0-9]+(\.[0-9]+)?' || true)

          if [ -z "$numeric_test_id" ] || [ -z "$numeric_estimate" ]; then
            echo "❌ Could not extract numeric values from TestID or Estimate" >&2
            exit 1
          fi

          echo "numeric_test_id=$numeric_test_id" >> $GITHUB_OUTPUT
          echo "numeric_estimate=$numeric_estimate" >> $GITHUB_OUTPUT

      #────────────────────────────────────────────────────────────────────────────
      # ... your remaining production steps go here, referencing:
      #     ${{ steps.extract_numeric.outputs.numeric_test_id }}
      #     ${{ steps.extract_numeric.outputs.numeric_estimate }}
      #     plus all the other parsed fields:
      #       ${{ steps.parse_body.outputs.start_date }}, etc.
      #────────────────────────────────────────────────────────────────────────────


      ################################################################
      # STEP 5a: Find the previous [Manual Test] issue for same author
      ################################################################
      - name: Find previous [Manual Test] issue
        id: find_previous
        uses: actions/github-script@v6
        with:
          script: |
            const currentNum = github.event.issue.number;
            const authorLogin = github.event.issue.user.login;
            const { owner, repo } = context.repo;

            // search for issues in this repo
            // label=manual-test, author=..., in:title "[Manual Test]"
            // sorted desc by created => exclude current
            const q = `repo:${owner}/${repo} is:issue label:manual-test author:${authorLogin} in:title "[Manual Test]"`;
            const searchResp = await github.rest.search.issuesAndPullRequests({
              q,
              sort: 'created',
              order: 'desc',
              per_page: 10
            });

            const results = searchResp.data.items.filter(i => i.number !== currentNum);
            if (!results.length) {
              core.info("No previous [Manual Test] issue found for same author => no Start Date to set.");
              core.setOutput('previous_issue_number', '');
              return;
            }

            const prevIssue = results[0];
            core.info(`Found previous issue #${prevIssue.number}, title="${prevIssue.title}"`);
            core.setOutput('previous_issue_number', prevIssue.number.toString());

      ################################################################
      # STEP 5b: Retrieve the previous issue's "End Date"
      ################################################################
      - name: Read previous End Date
        id: read_end_date
        if: steps.find_previous.outputs.previous_issue_number != ''
        uses: actions/github-script@v6
        with:
          script: |
            const prevNum = parseInt(core.getInput('previous_issue_number'), 10);
            const { owner, repo } = context.repo;

            // fetch the node_id
            const issueResp = await github.rest.issues.get({
              owner,
              repo,
              issue_number: prevNum
            });
            const prevNodeId = issueResp.data.node_id;
            if (!prevNodeId) {
              core.notice(`No node_id for #${prevNum}, skipping 'End Date' retrieval.`);
              return;
            }

            // find the project item(s)
            const itemsQuery = `
              query($issueId: ID!) {
                node(id: $issueId) {
                  ... on Issue {
                    projectItems(first: 50) {
                      nodes {
                        id
                        project {
                          title
                        }
                      }
                    }
                  }
                }
              }
            `;
            const itemData = await github.graphql(itemsQuery, { issueId: prevNodeId });
            const items = itemData.node?.projectItems?.nodes || [];

            let foundEnd = '';
            for (const it of items) {
              const fQuery = `
                query($itemId: ID!) {
                  node(id: $itemId) {
                    ... on ProjectV2Item {
                      fieldValues(first: 50) {
                        nodes {
                          __typename
                          ... on ProjectV2ItemFieldDateValue {
                            field {
                              ... on ProjectV2FieldCommon {
                                id
                                name
                              }
                            }
                            date
                          }
                        }
                      }
                    }
                  }
                }
              `;
              const fResp = await github.graphql(fQuery, { itemId: it.id });
              const fieldNodes = fResp.node?.fieldValues?.nodes || [];
              for (const fn of fieldNodes) {
                if (fn.field?.name === "End Date" && fn.__typename === "ProjectV2ItemFieldDateValue") {
                  if (fn.date) {
                    foundEnd = fn.date;
                    break;
                  }
                }
              }
              if (foundEnd) break;
            }

            core.info(`Previous #${prevNum} => End Date='${foundEnd}'`);
            core.setOutput('prev_end_date', foundEnd);

      ################################################################
      # STEP 5c: Update current issue's fields
      #           (set Start Date, End Date if needed, plus TestID, etc.)
      ################################################################
      - name: Update project fields for current issue
        id: update_fields
        uses: actions/github-script@v6
        with:
          script: |
            // Gather inputs
            const testIdNum = core.getInput('numeric_id'); // from parse_table
            const estimateRaw = core.getInput('estimate_num');
            const testResult = core.getInput('test_result');
            const osUsed = core.getInput('os_used');
            const lvVers = core.getInput('labview_version');
            const lvBit = core.getInput('labview_bitness');
            const notes = core.getInput('notes');
            const prevEnd = core.getInput('prev_end_date'); // might be blank
            const createdAt = github.event.issue.created_at; 
            const issueNodeId = github.event.issue.node_id;

            if (!issueNodeId) {
              core.setFailed("No node_id on current issue. Cannot update project items.");
              return;
            }

            let estimateNum = null;
            try {
              estimateNum = parseFloat(estimateRaw);
            } catch(e) {
              // fallback
              estimateNum = 0;
            }

            // 1) Query project items for this issue
            const itemsQ = `
              query($id: ID!) {
                node(id: $id) {
                  ... on Issue {
                    projectItems(first: 50) {
                      nodes {
                        id
                        project {
                          id
                          title
                        }
                      }
                    }
                  }
                }
              }
            `;
            const resp = await github.graphql(itemsQ, { id: issueNodeId });
            const items = resp.node?.projectItems?.nodes || [];
            if (!items.length) {
              core.info("Issue is not assigned to any project => skipping field updates.");
              return;
            }

            // 2) For each item, read current field values => update them
            async function readFields(itemId) {
              const qry = `
                query($itemId: ID!) {
                  node(id: $itemId) {
                    ... on ProjectV2Item {
                      fieldValues(first: 50) {
                        nodes {
                          __typename
                          ... on ProjectV2ItemFieldTextValue {
                            field { ... on ProjectV2FieldCommon { id name } }
                            text
                          }
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            field { ... on ProjectV2FieldCommon { id name } }
                            name
                          }
                          ... on ProjectV2ItemFieldDateValue {
                            field { ... on ProjectV2FieldCommon { id name } }
                            date
                          }
                          ... on ProjectV2ItemFieldNumberValue {
                            field { ... on ProjectV2FieldCommon { id name } }
                            number
                          }
                        }
                      }
                    }
                  }
                }
              `;
              const r = await github.graphql(qry, { itemId });
              return r.node?.fieldValues?.nodes || [];
            }

            async function updateFieldValue(projectId, itemId, fieldId, valObj) {
              const mut = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $val: ProjectV2FieldValue!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: $val
                  }) {
                    projectV2Item { id }
                  }
                }
              `;
              await github.graphql(mut, {
                projectId,
                itemId,
                fieldId,
                val: valObj
              });
            }

            for (const it of items) {
              core.info(`Updating itemId='${it.id}' in project='${it.project.title}'`);

              const fieldNodes = await readFields(it.id);
              // Build map => name -> {id, typeName, currentValue}
              const map = {};
              for (const fn of fieldNodes) {
                const fName = fn.field?.name;
                if (!fName) continue;

                let value;
                if (fn.__typename === 'ProjectV2ItemFieldTextValue') {
                  value = fn.text;
                } else if (fn.__typename === 'ProjectV2ItemFieldSingleSelectValue') {
                  value = fn.name;
                } else if (fn.__typename === 'ProjectV2ItemFieldDateValue') {
                  value = fn.date;
                } else if (fn.__typename === 'ProjectV2ItemFieldNumberValue') {
                  value = fn.number;
                }
                map[fName] = {
                  fieldId: fn.field.id,
                  typeName: fn.__typename,
                  current: value
                };
              }

              // Update "TestID" (Text)
              if (map["TestID"]) {
                await updateFieldValue(it.project.id, it.id, map["TestID"].fieldId, {
                  text: testIdNum
                });
              }

              // Update "LabVIEW Version" (Text)
              if (map["LabVIEW Version"]) {
                await updateFieldValue(it.project.id, it.id, map["LabVIEW Version"].fieldId, {
                  text: lvVers
                });
              }

              // "LabVIEW Bitness" (Text)
              if (map["LabVIEW Bitness"]) {
                await updateFieldValue(it.project.id, it.id, map["LabVIEW Bitness"].fieldId, {
                  text: lvBit
                });
              }

              // "Operating System" (Text)
              if (map["Operating System"]) {
                await updateFieldValue(it.project.id, it.id, map["Operating System"].fieldId, {
                  text: osUsed
                });
              }

              // "Test Result" (Single Select)
              if (map["Test Result"]) {
                // If it's singleSelectValue => { singleSelectValue: testResult }
                // If it was text => { text: testResult }
                if (map["Test Result"].typeName === 'ProjectV2ItemFieldSingleSelectValue') {
                  await updateFieldValue(it.project.id, it.id, map["Test Result"].fieldId, {
                    singleSelectValue: testResult
                  });
                } else {
                  // fallback if it was text
                  await updateFieldValue(it.project.id, it.id, map["Test Result"].fieldId, {
                    text: testResult
                  });
                }
              }

              // "Notes" (Text)
              if (map["Notes"]) {
                await updateFieldValue(it.project.id, it.id, map["Notes"].fieldId, {
                  text: notes
                });
              }

              // "Estimate" (Number)
              // parse estimateVal from estimateNum
              if (map["Estimate"]) {
                await updateFieldValue(it.project.id, it.id, map["Estimate"].fieldId, {
                  number: estimateNum
                });
              }

              // "End Date" => set once only if blank
              if (map["End Date"]) {
                if (!map["End Date"].current) {
                  await updateFieldValue(it.project.id, it.id, map["End Date"].fieldId, {
                    date: createdAt // use issue creation timestamp
                  });
                }
              }

              // "Start Date" => from prev_end_date if any, only if blank
              if (map["Start Date"] && prevEnd) {
                if (!map["Start Date"].current) {
                  await updateFieldValue(it.project.id, it.id, map["Start Date"].fieldId, {
                    date: prevEnd
                  });
                }
              }

              core.info("Item updated successfully.");
            }

            core.info("Finished updating fields for all assigned project items.");

      - name: Done
        run: echo "Workflow completed successfully."
